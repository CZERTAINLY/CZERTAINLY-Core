app:
  version: '@project.version@'

# Authentication and authorization
auth-service:
  base-url: ${AUTH_SERVICE_BASE_URL}
opa:
  base-url: ${OPA_BASE_URL}

# CMP settings
cmp:
  protocol:
    poll:
      feature:
        timeout: 20
  verbose: false

hibernate:
  types:
    print:
      banner: false

info:
  app:
    name: CZERTAINLY Core Version
    version: '@version@'

logging:
  level:
    com:
      czertainly: ${CZERTAINLY_LOG_LEVEL:INFO}
  pattern:
    console: '[%d{yyyy-MM-dd HH:mm:ss.SSS}] %-5level [%t] [%logger - %line]: %m%n'
    file: '[%d{yyyy-MM-dd HH:mm:ss.SSS}] %-5level [%t] [%logger - %line]: %m%n'
  schema-version: '@log-schema.version@'

# Configuration of actuator
management:
  endpoint:
    health:
      probes:
        enabled: true
  endpoints:
    web:
      base-path: /v1/
      exposure:
        include: health,info
  info:
    env:
      enabled: true

# OpenTelemetry settings
otel:
  exporter:
    otlp:
      logs:
        endpoint: ${OTEL_EXPORTER_OTLP_LOGS_ENDPOINT:http://localhost:4317}
        protocol: ${OTEL_EXPORTER_OTLP_LOGS_PROTOCOL:grpc}
      metrics:
        endpoint: ${OTEL_EXPORTER_OTLP_METRICS_ENDPOINT:http://localhost:4317}
        protocol: ${OTEL_EXPORTER_OTLP_METRICS_PROTOCOL:grpc}
      traces:
        endpoint: ${OTEL_EXPORTER_OTLP_TRACES_ENDPOINT:http://localhost:4317}
        protocol: ${OTEL_EXPORTER_OTLP_TRACES_PROTOCOL:grpc}
  logs:
    exporter: ${OTEL_LOGS_EXPORTER:none}
  metrics:
    exporter: ${OTEL_METRICS_EXPORTER:none}
  sdk:
    disabled: ${OTEL_SDK_DISABLED:true}
  traces:
    exporter: ${OTEL_TRACES_EXPORTER:none}

scheduled-tasks:
  enabled: ${SCHEDULED_TASKS_ENABLED:true}

scheduler:
  base-url: ${SCHEDULER_BASE_URL}

secrets:
  encryption:
    key: ${ENCRYPTION_KEY:J$-niT.PNp^?,wF<dB;E.W}

## Section server.* is related to the embedded Tomcat server only
server:
  port: ${PORT:8080}
  servlet:
    context-path: /api
  ssl:
    # Client certificate HTTP header name
    certificate-header-enabled: ${HEADER_ENABLED}
    certificate-header-name: ${HEADER_NAME:ssl-client-cert}
    client-auth: want
    enabled: ${SSL_ENABLE:false}
    trust-store: ${TS_PATH}
    trust-store-password: ${TS_PASSWORD}
    trust-store-type: JKS

# Settings
settings:
  cache:
    refresh-interval: ${SETTINGS_CACHE_REFRESH_INTERVAL:30}

spring:
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
  datasource:
    driver-class-name: org.postgresql.Driver
    hikari:
      connectionTimeout: ${CONNECTION_POOL_CONNECTION_TIMEOUT:30000}
      idleTimeout: ${CONNECTION_POOL_IDLE_TIMEOUT:600000}
      maxLifetime: ${CONNECTION_POOL_MAX_LIFETIME:1800000}
      maximumPoolSize: ${CONNECTION_POOL_MAX_POOL_SIZE:40}
    password: ${JDBC_PASSWORD}
    url: ${JDBC_URL}
    username: ${JDBC_USERNAME}
  flyway:
    out-of-order: true
    schemas: ${DB_SCHEMA:core}
    table: core_schema_history
  jpa:
    properties:
      hibernate:
        default_schema: ${DB_SCHEMA:core}
        jdbc:
          batch_size: 500
        order_inserts: true
        order_updates: true
        type:
          preferred_duration_jdbc_type: INTERVAL_SECOND
  messaging:
    broker-type: ${BROKER_TYPE:RABBITMQ} # possible values: RABBITMQ, SERVICEBUS
    broker-url: ${BROKER_URL}
    user: ${BROKER_USERNAME}
    password: ${BROKER_PASSWORD}
    session-cache-size: ${BROKER_SESSION_CACHE_SIZE:25}
    listener:
      recovery-interval: 5000
    producer:
      retry:
        enabled: true
        initial-interval: 3000
        max-attempts: 3
        max-interval: 10000
        multiplier: 2
    exchange: ${BROKER_EXCHANGE:czertainly}
    vhost: ${BROKER_VHOST:czertainly}
 # for rabbitMQ
    queue:
      actions: ${BROKER_QUEUE_ACTIONS:core.actions}
      audit-logs: ${BROKER_QUEUE_AUDIT_LOGS:core.audit-logs}
      event: ${BROKER_QUEUE_EVENT:core.event}
      notification: ${BROKER_QUEUE_NOTIFICATION:core.notification}
      scheduler: ${BROKER_QUEUE_SCHEDULER:core.scheduler}
      validation: ${BROKER_QUEUE_VALIDATION:core.validation}
    routing-key:
      actions: ${BROKER_ROUTINGKEY_ACTIONS:actions}
      audit-logs: ${BROKER_ROUTINGKEY_AUDIT_LOGS:audit-logs}
      event: ${BROKER_ROUTINGKEY_EVENT:event}
      notification: ${BROKER_ROUTINGKEY_NOTIFICATION:notification}
      scheduler: ${BROKER_ROUTINGKEY_SCHEDULER:scheduler}
      validation: ${BROKER_ROUTINGKEY_VALIDATION:validation}
  threads:
    virtual:
      enabled: true
  transaction:
    default-timeout: 20

messaging:
  concurrency:
    actions: 10
    events: 5
    notifications: 3
    scheduler: 10
    validation: 5
    audit-logs: 5

# Proxy configuration for connector communication via message queue
proxy:
  # Azure Service Bus topic / RabbitMQ exchange name for proxy messages
  exchange: ${PROXY_EXCHANGE:czertainly-proxy}
  # Azure Service Bus subscription / RabbitMQ queue name for receiving responses
  response-queue: ${PROXY_RESPONSE_QUEUE:core}
  # Maximum time to wait for a response from the proxy
  request-timeout: ${PROXY_REQUEST_TIMEOUT:30s}
  # Maximum number of concurrent pending requests (prevents memory exhaustion)
  max-pending-requests: ${PROXY_MAX_PENDING_REQUESTS:1000}
  # Redis pub/sub for distributed response routing in multi-instance deployments
  redis:
    # Channel name for broadcasting proxy responses across Core instances
    channel: ${PROXY_REDIS_CHANNEL:proxy:responses}
    # Enable Redis-based response distribution (required for multiple Core instances)
    enabled: ${PROXY_REDIS_ENABLED:false}

validation:
  crl:
    read-timeout: 2000
    connect-timeout: 1000
  ocsp:
    read-timeout: 1000
    connect-timeout: 1000
